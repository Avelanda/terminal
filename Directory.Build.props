<Project>
  <!--
    NOTE! This file gets written-over entirely by the release builds.
    Any build logic in this file must be optional and only apply to non-release builds.
  -->

  <!-- MsBuildCache -->
  <PropertyGroup>
    <!-- Off by default -->
    <MsBuildCacheEnabled Condition="'$(MsBuildCacheEnabled)' == ''">false</MsBuildCacheEnabled>

    <!-- Always off during package restore -->
    <MsBuildCacheEnabled Condition=" '$(ExcludeRestorePackageImports)' == 'true' ">false</MsBuildCacheEnabled>

    <!-- In Azure pipelines, use Pipeline Caching as the cache storage backend. Otherwise, use the local cache. -->
    <MSBuildCachePackageName Condition="'$(TF_BUILD)' != ''">Microsoft.MSBuildCache.AzurePipelines</MSBuildCachePackageName>
    <MSBuildCachePackageName Condition="'$(MSBuildCachePackageName)' == ''">Microsoft.MSBuildCache.Local</MSBuildCachePackageName>
  </PropertyGroup>

  <PropertyGroup Condition="'$(MSBuildCacheEnabled)' == 'true'">
    <!-- Change this to bust the cache -->
    <MSBuildCacheCacheUniverse Condition="'$(MSBuildCacheCacheUniverse)' == ''">202310210737</MSBuildCacheCacheUniverse>

    <!--
      Visual Studio telemetry reads various ApplicationInsights.config files and other files after the project is finished, likely in a detached process.
      This is acceptable and should not impact cache correctness.
    -->
    <MSBuildCacheAllowFileAccessAfterProjectFinishFilePatterns>
      $(MSBuildCacheAllowFileAccessAfterProjectFinishFilePatterns);
      \**\ApplicationInsights.config;
      $(LocalAppData)\Microsoft\VSApplicationInsights\**;
      $(LocalAppData)\Microsoft\Windows\INetCache\**;
      A:\;
      E:\;
      $(windir)\**;
      $(MSBuildBinPath)\**;
      $(MSBuildToolsPath32)\**;
    </MSBuildCacheAllowFileAccessAfterProjectFinishFilePatterns>

    <!--
      Unit tests may write to TEMP, but should not be considered outputs. However, $(Temp) is using the DOS path (C:\Users\CLOUDT~1\AppData\Local\Temp), which
      isn't accounted for in these globs. So we're building up to TEMP using $(LOCALAPPDATA) instead.
    -->
    <MSBuildCacheAllowFileAccessAfterProjectFinishFilePatterns>
      $(MSBuildCacheAllowFileAccessAfterProjectFinishFilePatterns);
      $(LOCALAPPDATA)\Temp\**;
    </MSBuildCacheAllowFileAccessAfterProjectFinishFilePatterns>

    <!-- 
      This repo uses a common output directory with many projects writing duplicate outputs. Allow everything, but note this costs some performance in the form of requiring
      the cache to use copies instead of hardlinks when pulling from cache.
    -->
    <MSBuildCacheIdenticalDuplicateOutputPatterns>$(MSBuildCacheIdenticalDuplicateOutputPatterns);bin\**</MSBuildCacheIdenticalDuplicateOutputPatterns>

    <!-- 
      vcpkg is invoked for each and every vcxproj and each invocation uses the same base dir for logging, so allow these duplicate "outputs".
    -->
    <MSBuildCacheIdenticalDuplicateOutputPatterns>$(MSBuildCacheIdenticalDuplicateOutputPatterns);obj\*\vcpkg\**</MSBuildCacheIdenticalDuplicateOutputPatterns>

    <!--
      Ensure the MSBuildCache ignores collecting outputs under vcpkg's build tree, which is a working directory used to build vcpkg packages and not intended to be consumed by anything else in the build.
      Note: We cannot use $(VcpkgInstalledDir) directly since it differs between projects, so use a pattern which encompasses all possibilities.
    -->
    <MSBuildCacheIgnoredOutputPatterns>
      $(MSBuildCacheIgnoredOutputPatterns);
      $(SolutionDir)\obj\*\vcpkg*\vcpkg\blds\**;
    </MSBuildCacheIgnoredOutputPatterns>

    <!-- version of MSBuildCache is not part of the cache key -->
    <PackagesConfigFile>$(MSBuildThisFileDirectory)\dep\nuget\packages.config</PackagesConfigFile>
    <MSBuildCacheIgnoredInputPatterns>$(MSBuildCacheIgnoredInputPatterns);$(PackagesConfigFile)</MSBuildCacheIgnoredInputPatterns>
  </PropertyGroup>

  <PropertyGroup Condition="'$(MSBuildCacheEnabled)' == 'true' and '$(MSBuildCachePackageRoot)' == ''">
    <PackagesConfigContents>$([System.IO.File]::ReadAllText("$(PackagesConfigFile)"))</PackagesConfigContents>
    <MSBuildCachePackageVersion>$([System.Text.RegularExpressions.Regex]::Match($(PackagesConfigContents), 'Microsoft.MSBuildCache.*?version="(.*?)"').Groups[1].Value)</MSBuildCachePackageVersion>
    <MSBuildCachePackageRoot>$(MSBuildThisFileDirectory)packages\$(MSBuildCachePackageName).$(MSBuildCachePackageVersion)</MSBuildCachePackageRoot>
    <MSBuildCacheSharedCompilationPackageRoot>$(MSBuildThisFileDirectory)packages\Microsoft.MSBuildCache.SharedCompilation.$(MSBuildCachePackageVersion)</MSBuildCacheSharedCompilationPackageRoot>
  </PropertyGroup>

  <ImportGroup Condition="'$(MSBuildCacheEnabled)' == 'true'">
    <Import Project="$(MSBuildCachePackageRoot)\build\$(MSBuildCachePackageName).props" />
    <Import Project="$(MSBuildCacheSharedCompilationPackageRoot)\build\Microsoft.MSBuildCache.SharedCompilation.props" />
  </ImportGroup>
</Project>